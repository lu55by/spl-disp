<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }
    </style>
    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.152.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.152.0/examples/jsm/",
            "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm"
          }
        }
    </script>

    <!--    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>-->
    <!--    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/loaders/OBJLoader.js"></script>-->
</head>

<body>
<div style="width: 100%; height: 100svh; background: linear-gradient(90deg, rgb(27, 27, 37), rgb(54, 54, 72), rgb(27, 27, 37));">
    <canvas style="width: 100%; height: 100%;" id="webgl"></canvas>
</div>

<script type="module">
    import * as THREE from 'three';
    import {OBJLoader} from "three/addons/loaders/OBJLoader.js";
    import {MTLLoader} from "three/addons/loaders/MTLLoader.js";
    import {OrbitControls} from "three/addons/controls/OrbitControls.js";
    import {GUI} from 'lil-gui';


    // let gui;
    // console.log('gui ->', GUI);


    const canvasEle = document.getElementById("webgl");
    console.log('canvasEle -> ', canvasEle);

    const wd = window;

    wd.isReady2Screenshot = false;

    // Head model path
    let headPathsPassed;
    // console.log("headModelPathPassed in three ->", headModelPathPassed);
    wd.addEventListener('headPaths-passed', () => {
        console.log('headPaths-passed from pptr ->', wd.headPaths);
        headPathsPassed = wd.headPaths;
        // gui = null;
    });

    // if (!headPathsPassed) gui = new GUI();

    // let strWindowPassed;
    // console.log("strWindowPassed in three ->", strWindowPassed);

    // wd.addEventListener('str-passed', () => {
    //     console.log('str-passed from pptr ->', wd.strPassed);
    //     strWindowPassed = wd.strPassed;
    // });


    // const width = wd.innerWidth;
    // const height = wd.innerHeight;
    const width = 1545;
    const height = 953;
    // console.log(width, height);

    const rendererClearColor = '#009';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
    // const renderer = new THREE.WebGLRenderer({antialias: true, alpha: true }); // Set alpha to true for transparency
    // const renderer = new THREE.WebGLRenderer({antialias: true});
    const renderer = new THREE.WebGLRenderer({canvas: canvasEle, antialias: true,}); // Set alpha to true for transparency
    renderer.setPixelRatio(Math.min(wd.devicePixelRatio, 2));
    renderer.setSize(width, height);
    renderer.setClearColor(rendererClearColor, 0); // Set clear color to transparent
    // renderer.setClearColor(rendererClearColor);
    renderer.setAnimationLoop(animate);
    renderer.shadowMap.enabled = true;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    // document.body.appendChild(renderer.domElement);

    // Lights
    const applyAppLights = () => {
        // === 改进的光源设置，更适合人头模型 ===
        // 主光（可旋转）
        const rotatingLight = new THREE.DirectionalLight(0xffffff, .6)
        rotatingLight.position.set(5, 10, 7)
        rotatingLight.castShadow = true
        scene.add(rotatingLight)

        // 补光 - 软化阴影
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.4)
        fillLight.position.set(-5, 3, 5)
        scene.add(fillLight)

        // 背光 - 增强轮廓
        const rimLight = new THREE.DirectionalLight(0xffffff, 0.3)
        rimLight.position.set(0, 3, -10)
        scene.add(rimLight)

        // 顶部环境光 - 确保头顶有足够的光线
        const topLight = new THREE.DirectionalLight(0xffffff, 0.25)
        topLight.position.set(0, 10, 0)
        scene.add(topLight)

        // 环境光 - 提供基础照明
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3)
        scene.add(ambientLight)

        // 半球光 - 提供更自然的环境照明
        const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.2)
        scene.add(hemisphereLight)
    };
    applyAppLights();

    // const ambientLight = new THREE.AmbientLight('#fff', 1);
    // scene.add(ambientLight);
    //
    // const directionalLight = new THREE.DirectionalLight('#fff', 3);
    // directionalLight.position.set(4, 3, 1)
    // scene.add(directionalLight);

    // Controls
    const orbitControls = new OrbitControls(camera, renderer.domElement);
    // orbitControls.enableDamping = true;
    // Axes Helper
    // scene.add(new AxesHelper(10));


    const modelGroup = new THREE.Group();

    // LoadModels


    const objLoader = new OBJLoader();
    const texLoader = new THREE.TextureLoader();
    // console.log('objLoader ->', objLoader);
    // console.log('texLoader ->', texLoader);

    const baseModelPath = 'http://192.168.10.17:8900/asset/model';

    // const xOffset = 0;
    // const yOffset = 100;
    // const zOffset = -70;

    // Hair
    const hairBasePath = `${baseModelPath}/hair`;
    const hairModelPathSuffix = '/man/背头/mold.obj';
    const hairModelTexPathSuffix = '/man/背头/map.png';

    const hairModelPath = `${hairBasePath + hairModelPathSuffix}`;
    const hairModelTexPath = `${hairBasePath + hairModelTexPathSuffix}`;

    const hairModel = await objLoader.loadAsync(hairModelPath);
    const hairNode = hairModel.children[0];
    const hairNodeTex = await texLoader.loadAsync(hairModelTexPath);
    hairNodeTex.colorSpace = THREE.SRGBColorSpace;
    hairNode.material.map = hairNodeTex;
    console.log('hairModel ->', hairModel);
    scene.add(hairModel);
    modelGroup.add(hairModel);

    // Head
    // headModelPath = 'http://192.168.10.17:8900/asset/model/head/2025-11-13-11-18-47-100271_58330/final.obj';
    if (headPathsPassed) {
        const {headModelPath, headColorTexPath, eyeColorLTexPath, eyeColorRTexPath} = headPathsPassed;
        const headModel = await objLoader.loadAsync(headModelPath);
        console.log('headModel ->', headModel);
        const headNode = headModel.getObjectByName('head_lod0_mesh');
        const eyeLNode = headModel.getObjectByName('eyeLeft_lod0_mesh');
        const eyeRNode = headModel.getObjectByName('eyeRight_lod0_mesh');
        const headNodeTex = await texLoader.loadAsync(headColorTexPath);
        headNodeTex.colorSpace = THREE.SRGBColorSpace;
        headNode.material.map = headNodeTex;
        const eyeLNodeTex = await texLoader.loadAsync(eyeColorLTexPath);
        eyeLNodeTex.colorSpace = THREE.SRGBColorSpace;
        eyeLNode.material.map = eyeLNodeTex;
        const eyeRNodeTex = await texLoader.loadAsync(eyeColorRTexPath);
        eyeRNodeTex.colorSpace = THREE.SRGBColorSpace;
        eyeRNode.material.map = eyeRNodeTex;
        scene.add(headModel);
        modelGroup.add(headModel);
    }

    // Str passed tst
    // strWindowPassed = "Passed tst str";
    // if (strWindowPassed) {
    //     scene.add(new THREE.Mesh(new THREE.BoxGeometry(10, 10, 10), new THREE.MeshNormalMaterial()));
    // }

    // Body
    const bodyBasePath = `${baseModelPath}/body`;
    const bodyModelPathSuffix = '/man/西装暴徒/mold.obj';
    const bodyModelTexPathSuffix = '/man/西装暴徒/map.png';

    const bodyModelPath = `${bodyBasePath + bodyModelPathSuffix}`;
    const bodyModelTexPath = `${bodyBasePath + bodyModelTexPathSuffix}`;

    const bodyModel = await objLoader.loadAsync(bodyModelPath);
    const bodyNode = bodyModel.children[0];
    const bodyNodeTex = await texLoader.loadAsync(bodyModelTexPath);
    bodyNodeTex.colorSpace = THREE.SRGBColorSpace;
    bodyNode.material.map = bodyNodeTex;
    console.log('bodyModel ->', bodyModel);
    scene.add(bodyModel);
    modelGroup.add(bodyModel);
    scene.add(modelGroup);

    modelGroup.position.set(-.051, -46.57, 87.83);
    modelGroup.rotation.set(.015, -.01, 0, "YXZ");
    // if (gui) addTransformDebug('Model Group', gui, modelGroup, {
    //     minPosVal: -100,
    //     maxPosVal: 150,
    //     step: .005,
    //     showRotation: true
    // });

    wd.isReady2Screenshot = true;

    // Funny little green cube
    // const geometry = new THREE.BoxGeometry();
    // const material = new THREE.MeshBasicMaterial({ color: 0x0ff, transparent: true, opacity: 0.5 });
    // const cube = new THREE.Mesh(geometry, material);
    // scene.add(cube);

    // Move the cam
    const camY = 90;
    camera.position.set(0, camY, 150);
    camera.updateProjectionMatrix();
    // camera.lookAt(new THREE.Vector3(0, 50, 0));

    // const camLookAtPos = new THREE.Vector3(0, 50, -10);
    // const camLookAtPos = new THREE.Vector3(0, 50, -10);

    // const clock = new THREE.Clock();
    // Render
    function animate() {
        // const elapsedTime = clock.getElapsedTime();
        // requestAnimationFrame(animate);

        // Animate body
        // if (womanBodyModel && womanBodyModel.isObject3D) {
        //     womanBodyModel.position.z = Math.sin(elapsedTime) * 100;
        // }

        // orbitControls.enabled = false;
        orbitControls.update();

        // camera.lookAt(new THREE.Vector3(0, 50, -.1));
        camera.lookAt(0, 80, -.1);


        // Rotate the cube
        // cube.rotation.x += step;
        // cube.rotation.y += step;

        // await renderer.ini
        renderer.render(scene, camera);
    }

    animate();


    // Model Loading fns


    // --- 加载OBJ头发模型 ---
    async function loadObj(path, options = {}) {
        const {mtlPath, scale, position, rotation} = options;

        // let materials: THREE.Material | THREE.Material[] | undefined;
        let materials

        // Load MTL (if provided)
        if (mtlPath) {
            const mtlLoader = new MTLLoader()
            materials = await new Promise < MTLLoader.MaterialCreator > ((resolve, reject) => {
                mtlLoader.load(
                    mtlPath,
                    (mtl) => {
                        mtl.preload();
                        resolve(mtl);
                    },
                    undefined,
                    reject);
            })
        }

        // Load OBJ
        const objLoader = new OBJLoader()
        if (materials) objLoader.setMaterials(materials)

        const loadedObj = await new Promise < THREE.Object3D > ((resolve, reject) => {
            objLoader.load(path, resolve, undefined, reject);
        });

        // Optional transforms
        if (position) loadedObj.position.copy(position);

        if (rotation) loadedObj.rotation.copy(rotation);

        if (scale) {
            if (typeof scale === 'number')
                loadedObj.scale.setScalar(scale);
            else loadedObj.scale.copy(scale);
        }


        return loadedObj;
    }

    function addTransformDebug(
        guiTitle,
        gui,
        obj,
        options = {}
    ) {
        const folder = gui.addFolder(obj.name || guiTitle);

        const minPos = options?.minPosVal || -10;
        const maxPos = options?.maxPosVal || 10;
        const step = options?.step || .01;

        // --- Position controls ---
        const posFolder = folder.addFolder('Position');
        posFolder.add(obj.position, 'x', minPos, maxPos, step).name('X').onChange(() => obj.updateMatrixWorld())
        posFolder.add(obj.position, 'y', minPos, maxPos, step).name('Y').onChange(() => obj.updateMatrixWorld())
        posFolder.add(obj.position, 'z', minPos, maxPos, step).name('Z').onChange(() => obj.updateMatrixWorld())

        // --- Rotation controls ---
        if (options?.showRotation) {
            const rotFolder = folder.addFolder('Rotation')
            rotFolder.add(obj.rotation, 'x', -Math.PI, Math.PI, step).name('Rot X')
            rotFolder.add(obj.rotation, 'y', -Math.PI, Math.PI, step).name('Rot Y')
            rotFolder.add(obj.rotation, 'z', -Math.PI, Math.PI, step).name('Rot Z')
        }

        // --- Scale controls ---
        if (options?.showScale) {
            const scaleFolder = folder.addFolder('Scale')
            // scaleFolder.add(obj.scale, 'x', step, 10, step).name('Scale X')
            // scaleFolder.add(obj.scale, 'y', step, 10, step).name('Scale Y')
            // scaleFolder.add(obj.scale, 'z', step, 10, step).name('Scale Z')

            // Store a local scalar value for GUI
            const scaleState = {
                scalar: obj.scale.x  // assumes uniform at start, safe for setScalar
            };

            scaleFolder
                .add(scaleState, "scalar", 0.001, .1, 0.0001)
                .name("uniformScale")
                .onChange((v) => {
                    obj.scale.setScalar(v);
                });
        }

        folder.open();
    }

</script>
</body>

</html>